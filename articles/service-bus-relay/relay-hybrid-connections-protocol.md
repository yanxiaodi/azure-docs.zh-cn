---
title: Azure 中继混合连接协议指南 | Microsoft 文档
description: Azure 中继混合连接协议指南。
services: service-bus-relay
documentationcenter: na
author: clemensv
manager: timlt
editor: ''
ms.assetid: 149f980c-3702-4805-8069-5321275bc3e8
ms.service: service-bus-relay
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 05/02/2018
ms.author: clemensv
ms.openlocfilehash: e96d0103a03e841f39e8adb88215f6d6e24a305a
ms.sourcegitcommit: d4dfbc34a1f03488e1b7bc5e711a11b72c717ada
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/13/2019
ms.locfileid: "64706090"
---
# <a name="azure-relay-hybrid-connections-protocol"></a>Azure 中继混合连接协议

Azure 中继是 Azure 服务总线平台最重要的功能支柱之一。 中继的新“混合连接”功能是基于 HTTP 和 WebSocket 的安全、开放协议演化版  。 它取代了之前基于专用协议构建的名为“BizTalk 服务”的功能  。 将混合连接集成到 Azure 应用服务并不影响原有的运行方式。

混合连接在两个联网应用程序之间启用双向二进制流通信和简单的数据报流。 任何一方或双方均可驻留在 NAT 或防火墙之后。

本文介绍如何与混合连接中继的客户端交互，以连接侦听器和发送方角色中的客户端。 此外，还介绍侦听器如何接受新的连接和请求。

## <a name="interaction-model"></a>交互模型

混合连接中继将通过提供双方都可在自身网络发现并连接到的 Azure 云中的集合点来连接两方。 该集合点就是在本文和其他文档、API 及 Azure 门户中提及的“混合连接”。 混合连接服务终结点在本文其余部分被称为“服务”。

该服务允许中继 Web 套接字连接和 HTTP(S) 请求与响应。

该交互模型倾向于使用由许多其他网络服务 API 创建的术语： 有一个侦听器可以先指明是否准备好处理传入连接，再在这些连接到达时接受它们。 在另一端，某个客户端会连接到侦听器，预期该连接被接受以建立双向通信路径。 “连接”、“侦听”和“接受”与大多数套接字 API 中找到的术语相同。

任何中继通信模型都会使双方生成针对服务终结点的出站连接。 这使得“侦听器”也常被说成“客户端”，可能还会导致其他术语重载。 因此，用于混合连接的准确术语如下：

连接两端上的程序称为“客户端”，因为相对于服务，它们是客户端。 等待和接受连接的客户端是“侦听器”，或者称其在“侦听器角色”中。 通过服务向侦听器启动新连接的客户端称为“发送方”，或者称其在“发送方角色”中。

### <a name="listener-interactions"></a>侦听器交互

侦听器与服务之间存在五种交互，所有通信详细信息都已在本文后续参考部分中予以说明。

从服务接收“侦听”、“接受”和“请求”消息。 侦听器发送“续订”和“Ping”操作。

#### <a name="listen-message"></a>侦听消息

侦听器会创建一个出站 WebSocket 连接，指示对服务的准备情况，即侦听器准备接受连接的情况。 连接握手包含中继命名空间所配置的混合连接名称，以及授予对该名称“侦听”权限的安全令牌。

服务接受 WebSocket 后，注册完成并且建立的 WebSocket 作为“控制通道”保持活动状态，以支持所有后续交互。 在一个混合连接上服务最多可允许 25 个并行侦听器。 AppHooks 的配额待定。

对于混合连接，如果有两个或更多活动的侦听器，则将传入连接以随机顺序均衡分布在这些侦听器上；尽最大努力实现平均分配。

#### <a name="accept-message"></a>接受消息

发送方打开服务上的新连接时，服务会选择并通知混合连接上活动的侦听器之一。 此通知作为 JSON 消息通过打开的控制通道发送到侦听器。 该消息包含侦听器为了接受连接而必须连接到的 Web 套接字终结点的 URL。

该 URL 可以且必须直接由侦听器使用，无需任何额外作业。
编码信息仅在短时间内有效，基本上为发送方愿意等待的端到端创建连接的时间。 假设最长时间为 30 秒。 该 URL 只能用于一次成功的连接尝试。 使用集合 URL 建立 Web 套接字连接后，该 Web 套接字上的所有后续活动都将与发送方来回中继。 无需服务进行任何干预或转译即会发生此操作。

### <a name="request-message"></a>请求消息

除了 Web 套接字连接以外，侦听器还可以从发送方接收 HTTP 请求帧（如果已对混合连接显式启用此功能）。

附加到混合连接的、支持 HTTP 的侦听器必须处理 `request` 手势。 不处理 `request`，因而导致连接时重复出现超时错误的侦听器将来可能会被服务列入阻止列表。

HTTP 帧标头元数据将转换为 JSON，以方便由侦听器框架处理；执行这种转换的另一个原因是，相比 JSON 分析器，HTTP 标头分析库极其少见。 仅与发送方与中继 HTTP 网关之间的关系相关的 HTTP 元数据（包括授权信息）不会转发。 HTTP 请求正文以透明方式作为二进制 Web 套接字帧传输。

侦听器可以使用等效的响应手势来响应 HTTP 请求。

请求/响应流默认使用控制通道，但可根据需要“升级”到不同的会合 Web 套接字。 不同的 Web 套接字连接会提高每个客户端对话的吞吐量，但它们会增大侦听器需要处理的连接负担，因此不一定适合对轻型客户端使用此方案。

在控制通道上，请求和响应正文大小限制为最大 64 kB。 HTTP 标头元数据限制为总共 32 kB。 如果请求或响应超过该阈值，必须使用与[接受](#accept-message)处理方法相当的手势，将侦听器升级到会合 Web 套接字。

对于请求，服务会决定是否通过控制通道来路由请求。 这包括但不限于请求完全超过 64 kB（标头和正文）、使用[“分块”传输编码](https://tools.ietf.org/html/rfc7230#section-4.1)发送请求，并且服务有理由预测请求会超过 64 kB，或者读取请求不是即时发生的情况。 如果服务选择通过会合点传送请求，它只会将会合地址传递给侦听器。
然后，侦听器必须建立会合 Web 套接字，并且服务会立即通过会合 Web 套接字传送完整的请求（包括正文）。 响应也必须使用会合 Web 套接字。

对于通过控制通道抵达的请求，侦听器会决定是要通过控制通道还是会合点做出响应。 服务必须包含一个会合地址，将在该地址中通过控制通道路由每个请求。 只有在从当前请求升级时，此地址才有效。

如果侦听器选择升级，则它会建立连接，并立即通过建立的会合套接字传送响应。

建立会合 Web 套接字后，侦听器应保留该 Web 套接字，以便进一步处理来自同一客户端的请求和响应。 服务保留 Web 套接字的持续时间与发送方的 HTTPS 套接字连接保持时间相同，会通过保留的 Web 套接字路由来自该发送方的所有后续请求。 如果侦听器选择删除其所在一端的会合 Web 套接字，服务也会删除与发送方之间的连接，不管后续的请求是否已在处理中。

#### <a name="renew-operation"></a>续订操作

注册侦听器和维护控制通道必须使用的安全令牌可能会在侦听器活动期间到期。 令牌到期不会影响正在进行的连接，但会导致服务在到期时或到期不久后终止控制通道。 “续订”操作是一个 JSON 消息，侦听器可以发送它来替换与控制通道关联的令牌，这样即可延长控制通道的维护时间。

#### <a name="ping-operation"></a>Ping 操作

如果控制通道长时间处于空闲，通道上的中介，例如负载均衡器或 NAT 可能会终止 TCP 连接。 “ping”操作可通过在该通道上发送少量数据，提醒网络路由上的所有人该连接处于活动状态，以此来避免上述终止情况；此操作还可充当侦听器的“实时”测试。 如果 ping 失败，则控制通道应视为不可用，并且侦听器应重新进行连接。

### <a name="sender-interaction"></a>发送方交互

发送方与服务之间存在两种交互：连接 Web 套接字，或通过 HTTPS 发送请求。 无法从发送方角色通过 Web 套接字发送请求。

#### <a name="connect-operation"></a>连接操作

“连接”操作会打开服务上的 WebSocket，提供混合连接的名称和（可选，但默认为必需）授予查询字符串中“发送”权限的安全令牌。 然后，服务会按照之前所述的方式与侦听器进行交互，并且侦听器会创建一个与此 WebSocket 联接的集合连接。 WebSocket 被接受后，该 WebSocket 上的所有后续交互都将使用已连接的侦听器。

#### <a name="request-operation"></a>请求操作

对于启用了该功能的混合连接，发送方可以向侦听器发送限制程度极低的 HTTP 请求。

但嵌入在查询字符串或请求 HTTP 标头中的中继访问令牌除外。对于针对中继地址和中继地址路径中所有后缀执行的所有 HTTP 操作而言，中继是完全透明的，使侦听器能够完全控制端到端授权甚至 [CORS](https://www.w3.org/TR/cors/) 等 HTTP 扩展功能。

对中继终结点的发送方授权默认已启用，但可以选择禁用。 混合连接的所有者可以选择允许匿名发送方。 服务会截获、检查和剥离授权信息，如下所述：

1. 如果查询字符串包含 `sb-hc-token` 表达式，则始终会从查询字符串中剥离该表达式。 如果已启用中继授权，则会评估该表达式。
2. 如果请求标头包含 `ServiceBusAuthorization` 标头，则始终会从标头集合中剥离标头表达式。
   如果已启用中继授权，则会评估该表达式。
3. 仅当已启用中继授权、请求标头包含 `Authorization` 标头并且上述表达式都不存在时，才会评估并剥离标头。 否则，始终按原样传递 `Authorization`。

如果没有活动的侦听器，服务会返回“错误的网关”502 错误代码。 如果服务似乎未处理请求，则在 60 秒后会返回“网关超时”504 错误代码。

### <a name="interaction-summary"></a>交互摘要

此交互模型的结果是，发送方客户端使用“干净”的 WebSocket（已连接侦听器且无需进一步的“报头”或准备）离开握手。 凭借此模型，几乎任何现有 Web 套接字客户端实现通过将正确构造的 URL 提供到其 Web 套接字客户端层，即可立即使用混合连接服务。

侦听器通过接受交互获取的集合连接 WebSocket 同样也是干净的，并且可被传递到任何现有 WebSocket 服务器实现，使用一些最小限度的额外抽象层，区分其框架的本地网络侦听器上的“接受”操作和混合连接远程“接受”操作。

HTTP 请求/响应模型为发送方提供受限程度极低的 HTTP 协议外围应用，其中包含可选的授权层。 侦听器获取预先分析的 HTTP 请求标头节，可以使用携带 HTTP 正文的二进制帧，将该节转换回到下游 HTTP 请求，或按原样进行处理。 响应使用相同的格式。 可以通过与所有发送方共享的单个 Web 套接字，来处理与 64 KB 以下的请求和响应正文的交互。 可以使用会合模型处理更大的请求和响应。

## <a name="protocol-reference"></a>协议参考

本部分介绍前述协议交互的详细信息。

所有 WebSocket 连接都作为 HTTPS 1.1 的升级在端口 443 上生成，此操作通常被一些 WebSocket 框架或 API 抽象化。 此处的说明保持实现中立，不指示特定框架。

### <a name="listener-protocol"></a>侦听器协议

侦听器协议由两个连接动作和三个消息操作组成。

#### <a name="listener-control-channel-connection"></a>侦听器控制通道连接

控制通道通过创建针对以下内容的 WebSocket 连接打开：

`wss://{namespace-address}/$hc/{path}?sb-hc-action=...[&sb-hc-id=...]&sb-hc-token=...`

`namespace-address` 是托管混合连接的 Azure 中继命名空间的完全限定域名，通常格式为 `{myname}.servicebus.windows.net`。

查询字符串参数选项如下所示。

| 参数        | 需要 | 描述
| ---------------- | -------- | -------------------------------------------
| `sb-hc-action`   | 是      | 对于侦听器角色，该参数必须是 **sb-hc-action=listen**
| `{path}`         | 是      | 要注册该侦听器的预配置混合连接的 URL 编码命名空间路径。 此表达式追加至固定的 `$hc/` 路径部分。
| `sb-hc-token`    | 是\*    | 侦听器必须为命名空间或混合连接提供有效的 URL 编码的服务总线共享访问令牌，以授予“**侦听**”权限。
| `sb-hc-id`       | 否       | 该客户端提供的可选 ID 可实现端到端诊断跟踪。

如果由于混合连接路径未注册、令牌无效或丢失或其他一些错误，导致 WebSocket 连接失败，则会使用常规的 HTTP 1.1 状态反馈模型提供错误反馈。 状态说明包含可传达给 Azure 支持人员的错误跟踪 ID：

| 代码 | 错误          | 描述
| ---- | -------------- | -------------------------------------------------------------------
| 404  | 未找到      | 混合连接路径无效或基 URL 格式不正确。
| 401  | 未授权   | 安全令牌丢失或格式不正确或无效。
| 403  | 禁止      | 安全令牌对此操作的此路径无效。
| 500  | 内部错误 | 服务内部出错。

如果服务在初始设置 WebSocket 连接后有意将其关闭，则会使用相应的 WebSocket 协议错误代码，连同也包含跟踪 ID 的描述性错误消息传达执行此操作的原因。 服务在未出现错误状况的情况下将不会关闭控制通道。 任何干净关闭都由客户端控制。

| WS 状态 | 描述
| --------- | -------------------------------------------------------------------------------
| 1001      | 混合连接路径已删除或禁用。
| 1008      | 安全令牌已到期，因此违背了授权策略。
| 1011      | 服务内部出错。

#### <a name="accept-handshake"></a>接受握手

“接受”通知作为 WebSocket 文本框中的 JSON 消息，由服务通过之前建立的控制通道发送到侦听器。 不会对此消息进行任何回复。

该消息包含名为“accept”的 JSON 对象，此时该对象定义以下属性：

* address – 用于创建服务的 WebSocket URL 字符串，以接受传入连接  。
* **id** – 该连接的唯一标识符。 如果该 ID 由发送方客户端提供，则是发送方提供的值，否则为系统生成的值。
* **connectHeaders** – 发送方向中继终结点提供的所有 HTTP 头，其中也包括 Sec-WebSocket-Protocol 和 Sec-WebSocket-Extensions 头。

```json
{
    "accept" : {
        "address" : "wss://dc-node.servicebus.windows.net:443/$hc/{path}?..."
        "id" : "4cb542c3-047a-4d40-a19f-bdc66441e736",
        "connectHeaders" : {
            "Host" : "...",
            "Sec-WebSocket-Protocol" : "...",
            "Sec-WebSocket-Extensions" : "..."
        }
     }
}
```

侦听器使用 JSON 消息中提供的地址 URL，创建接受或拒绝发送方套接字的 WebSocket。

##### <a name="accepting-the-socket"></a>接受套接字

若接受，侦听器会创建对已提供地址的 WebSocket 连接。

如果“接受”消息包含 `Sec-WebSocket-Protocol` 头，则预计只有在侦听器支持该协议时，才会接受 WebSocket。 此外，侦听器还应在创建 WebSocket 时设置该头。

这同样适用于 `Sec-WebSocket-Extensions` 头。 如果框架支持扩展，则框架应针对扩展将头设置为所需 `Sec-WebSocket-Extensions` 握手的服务器端回复。

URL 必须原样使用，用于创建接受套接字，但是要包含以下参数：

| 参数      | 必选 | 描述
| -------------- | -------- | -------------------------------------------------------------------
| `sb-hc-action` | 是      | 若要接受套接字，该参数必须为 `sb-hc-action=accept`
| `{path}`       | 是      | （请参阅下文）
| `sb-hc-id`     | 否       | 请参阅上述的 ID 说明  。

`{path}` 是要注册此侦听器的预配置混合连接的 URL 编码命名空间路径。 此表达式追加至固定的 `$hc/` 路径部分。

`path` 表达式可以使用后缀和查询字符串表达式进行扩展，该表达式在分隔正斜杠之后追加注册名称。
这样，发送方客户端就可以在无法包含 HTTP 头时将调度参数传递到接受侦听器。 侦听器框架可从路径中分析出固定路径部分和注册名称，并向应用程序提供其余部分（可能不含任何带 `sb-` 前缀的查询字符串参数），以决定是否接受连接。

有关详细信息，请参阅后面的“发送方协议”部分。

如果出现错误，服务可能会提供以下回复：

| 代码 | 错误          | 描述
| ---- | -------------- | -----------------------------------
| 403  | 禁止      | 此 URL 无效。
| 500  | 内部错误 | 服务内部出错

 建立连接后，服务器会在发送方 WebSocket 关闭后或在以下状态下关闭 WebSocket：

| WS 状态 | 描述                                                                     |
| --------- | ------------------------------------------------------------------------------- |
| 1001      | 发送方客户端关闭连接。                                    |
| 1001      | 混合连接路径已删除或禁用。                        |
| 1008      | 安全令牌已到期，因此违背了授权策略。 |
| 1011      | 服务内部出错。                                            |

##### <a name="rejecting-the-socket"></a>拒绝套接字

 在检查 `accept` 消息后拒绝套接字，将需要一个相似的握手，以使传达拒绝原因的状态代码和状态说明可以返回至发送方。

 此处的协议设计选项是使用 WebSocket 握手（用于在定义的错误状态下结束），以便侦听器客户端实现可以继续依赖 WebSocket 客户端，而无需使用其他的裸 HTTP 客户端。

 若要拒绝套接字，客户端需使用 `accept` 消息中的地址 URI 并将两个查询字符串参数追加到其中，如下所示：

| Param                   | 必选 | 描述                              |
| ----------------------- | -------- | ---------------------------------------- |
| sb-hc-statusCode        | 是      | 数值型 HTTP 状态代码。                |
| sb-hc-statusDescription | 是      | 可人工读取的拒绝原因。 |

然后，使用生成的 URI 建立 WebSocket 连接。

正确完成后，该握手会有意失败，并出现 HTTP 错误代码 410，因为尚未创建任何 WebSocket。 如果出现问题，会使用以下代码描述问题：

| 代码 | 错误          | 描述                          |
| ---- | -------------- | ------------------------------------ |
| 403  | 禁止      | 此 URL 无效。                |
| 500  | 内部错误 | 服务内部出错。 |

#### <a name="request-message"></a>请求消息

服务通过控制通道将 `request` 消息发送到侦听器。 也可以通过建立的会合 Web 套接字发送同一消息。

`request` 由两个部分组成：标头和二进制正文帧。
如果没有正文，则会省略正文帧。 请求消息中的布尔值 `body` 属性指示是否存在正文。

对于包含请求正文的请求，结构可能如下所示：

``` text
----- Web Socket text frame ----
{
    "request" :
    {
        "body" : true,
        ...
    }
}
----- Web Socket binary frame ----
FEFEFEFEFEFEFEFEFEFEF...
----- Web Socket binary frame ----
FEFEFEFEFEFEFEFEFEFEF...
----- Web Socket binary frame -FIN
FEFEFEFEFEFEFEFEFEFEF...
----------------------------------
```

侦听器必须处理拆分到多个二进制帧之间的请求正文的接收（请参阅 [Web 套接字片段](https://tools.ietf.org/html/rfc6455#section-5.4)）。
收到设置了 FIN 标志的二进制帧时，请求结束。

对于不包含正文的请求，只有一个文本帧。

``` text
----- Web Socket text frame ----
{
    "request" :
    {
        "body" : false,
        ...
    }
}
----------------------------------
```

`request` 的 JSON 内容如下：

* **address** - URI 字符串。 这是用于此请求的会合地址。 如果传入的请求大于 64 kB，则此消息的余下部分将会留空，并且客户端必须启动等同于如下所述 `accept` 操作的会合握手。 然后，服务将在建立的 Web 套接字放置完整的 `request`。 如果响应预期可能超过 64 kB，则侦听器也必须启动会合握手，然后通过建立的 Web 套接字传输响应。
* **id** – 字符串。 此请求的唯一标识符。
* **requestHeaders** – 此对象包含由发送方提供给终结点的所有 HTTP 标头（[上面](#request-operation)所述的授权信息除外），以及与网关连接严格相关的标头。 具体而言，在 [RFC7230](https://tools.ietf.org/html/rfc7230) 中定义或保留的所有标头（`Via` 除外）都会被剥离，而不会转发：

  * `Connection`（RFC7230 第 6.1 部分）
  * `Content-Length`（RFC7230 第 3.3.2 部分）
  * `Host`（RFC7230 第 5.4 部分）
  * `TE`（RFC7230 第 4.3 部分）
  * `Trailer`（RFC7230 第 4.4 部分）
  * `Transfer-Encoding`（RFC7230 第 3.3.1 部分）
  * `Upgrade`（RFC7230 第 6.7 部分）
  * `Close`（RFC7230 第 8.1 部分）

* **requestTarget** – 字符串。 此属性保存请求的[“请求目标”（RFC7230 第 5.3 部分）](https://tools.ietf.org/html/rfc7230#section-5.3)。 这包括查询字符串部分，其所有 `sb-hc-` 前缀参数已剥离。
* **method** - 字符串。 这是 [RFC7231 第 4 部分](https://tools.ietf.org/html/rfc7231#section-4)所述的请求方法。 不得使用 `CONNECT` 方法。
* **bool** – 布尔值。 指示是否后接一个或多个二进制正文帧。

``` JSON
{
    "request" : {
        "address" : "wss://dc-node.servicebus.windows.net:443/$hc/{path}?...",
        "id" : "42c34cb5-7a04-4d40-a19f-bdc66441e736",
        "requestTarget" : "/abc/def?myarg=value&otherarg=...",
        "method" : "GET",
        "requestHeaders" : {
            "Host" : "...",
            "Content-Type" : "...",
            "User-Agent" : "..."
        },
        "body" : true
     }
}
```

##### <a name="responding-to-requests"></a>响应请求

接收方必须做出响应。 在保持连接期间一直不响应请求可能导致侦听器被列入阻止列表。

响应可按任意顺序发送，但必须在 60 秒内响应每个请求，否则会将传送报告为失败。 在服务收到 `response` 帧之前，会进行 60 秒倒计时。 包含多个二进制帧的处理中响应不能空闲 60 秒以上，否则会将其终止。

如果通过控制通道收到了请求，则必须在控制通道上从收到请求的位置发送响应，否则，必须通过会合通道发送响应。

响应是名为“response”的 JSON 对象。 正文内容的处理规则与 `request` 消息的处理方式相同，并基于 `body` 属性。

* **requestId** – 字符串。 必需。 正在响应的 `request` 消息的 `id` 属性值。
* **statusCode** – 数字。 必需。 指示通知结果的数字 HTTP 状态代码。 允许 [RFC7231 第 6 部分](https://tools.ietf.org/html/rfc7231#section-6)所述的所有状态代码，但 [502“错误的网关”](https://tools.ietf.org/html/rfc7231#section-6.6.3)和 [504“网关超时”](https://tools.ietf.org/html/rfc7231#section-6.6.5)除外。
* **statusDescription** - 字符串。 可选。 [RFC7230 第 3.1.2 部分](https://tools.ietf.org/html/rfc7230#section-3.1.2)所述的 HTTP 状态代码原因短语
* **responseHeaders** – 要在外部 HTTP 回复中设置的 HTTP 标头。
  与 `request` 一样，不得使用 RFC7230 定义的标头。
* **bool** – 布尔值。 指示是否后接二进制正文帧。

``` text
----- Web Socket text frame ----
{
    "response" : {
        "requestId" : "42c34cb5-7a04-4d40-a19f-bdc66441e736",
        "statusCode" : "200",
        "responseHeaders" : {
            "Content-Type" : "application/json",
            "Content-Encoding" : "gzip"
        }
         "body" : true
     }
}
----- Web Socket binary frame -FIN
{ "hey" : "mydata" }
----------------------------------
```

##### <a name="responding-via-rendezvous"></a>通过会合点响应

对于超过 64 kB 的响应，必须通过会合套接字传送响应。 此外，如果请求超过 64 kB，并 `request` 仅包含地址字段，则必须建立会合套接字以获取 `request`。 建立会合套接字后，必须通过持久保留的会合套接字传送对该相应客户端的响应，以及来自该相应客户端的后续请求。

`request` 中的 `address` URL 必须原样使用，用于建立会合套接字，但要包含以下参数：

| 参数      | 必选 | 描述
| -------------- | -------- | -------------------------------------------------------------------
| `sb-hc-action` | 是      | 若要接受套接字，该参数必须为 `sb-hc-action=request`

如果出现错误，服务可能会提供以下回复：

| 代码 | 错误           | 描述
| ---- | --------------- | -----------------------------------
| 400  | 请求无效 | 无法识别的操作，或 URL 无效。
| 403  | 禁止       | URL 已过期。
| 500  | 内部错误  | 服务内部出错

 建立连接后，服务器会在客户端的 HTTP 套接字关闭后或处于以下状态时关闭 Web 套接字：

| WS 状态 | 描述                                                                     |
| --------- | ------------------------------------------------------------------------------- |
| 1001      | 发送方客户端关闭连接。                                    |
| 1001      | 混合连接路径已删除或禁用。                        |
| 1008      | 安全令牌已到期，因此违背了授权策略。 |
| 1011      | 服务内部出错。                                            |


#### <a name="listener-token-renewal"></a>侦听器令牌续订

侦听器令牌即将到期时，可以通过已创建的控制通道向服务发送文本框消息来替换令牌。 消息包含名为 `renewToken` 的 JSON 对象，此时该对象定义以下属性：

* token – 命名空间或混合连接的有效 URL 编码的服务总线共享访问令牌，可授予“侦听”权限   。

```json
{
  "renewToken": {
    "token":
      "SharedAccessSignature sr=http%3a%2f%2fcontoso.servicebus.windows.net%2fhyco%2f&amp;sig=XXXXXXXXXX%3d&amp;se=1471633754&amp;skn=SasKeyName"
  }
}
```

如果令牌验证失败，访问被拒绝，则云服务会关闭控制通道 WebSocket 并显示错误。 否则，不会有任何回复。

| WS 状态 | 描述                                                                     |
| --------- | ------------------------------------------------------------------------------- |
| 1008      | 安全令牌已到期，因此违背了授权策略。 |

### <a name="web-socket-connect-protocol"></a>Web 套接字连接协议

发送方协议实际上与创建侦听器的方式相同。
其目标在于对端到端 WebSocket 实现最大透明度。 要连接到的地址与侦听器的相同，但是“操作”不同且令牌需要不同的权限：

```
wss://{namespace-address}/$hc/{path}?sb-hc-action=...&sb-hc-id=...&sbc-hc-token=...
```

_namespace-address_ 是托管混合连接的 Azure 中继命名空间的完全限定域名，通常格式为 `{myname}.servicebus.windows.net`。

请求可以包含任意其他 HTTP 头，包括应用程序定义的头。 所有提供的头均流向侦听器并且可在“接受”控制消息的 `connectHeader` 对象上找到  。

查询字符串参数选项如下所示：

| Param          | 必需？ | 描述
| -------------- | --------- | -------------------------- |
| `sb-hc-action` | 是       | 对于发送方角色，该参数必须是 `sb-hc-action=connect`。
| `{path}`       | 是       | （请参阅下文）
| `sb-hc-token`  | 是\*     | 侦听器必须为命名空间或混合连接提供有效的 URL 编码的服务总线共享访问令牌，以授予“**发送**”权限。
| `sb-hc-id`     | 否        | 启用端到端诊断跟踪的可选 ID，在接受握手期间会将其提供至侦听器。

 `{path}` 是要注册此侦听器的预配置混合连接的 URL 编码命名空间路径。 `path` 表达式可以使用后缀和查询字符串表达式进行扩展，以供进一步通信。 如果混合连接注册在路径 `hyco` 下，则 `path` 表达式可以是 `hyco/suffix?param=value&...`，后跟此处定义的查询字符串参数。 完整的表达式可能如下所示：

```
wss://{namespace-address}/$hc/hyco/suffix?param=value&sb-hc-action=...[&sb-hc-id=...&]sbc-hc-token=...
```

`path` 表达式传递到“接受”控制消息所含地址 URI 中的侦听器。

如果由于混合连接路径未注册、令牌无效或丢失或其他一些错误，导致 WebSocket 连接失败，则会使用常规的 HTTP 1.1 状态反馈模型提供错误反馈。 状态说明包含可传达给 Azure 支持人员的错误跟踪 ID：

| 代码 | 错误          | 描述
| ---- | -------------- | -------------------------------------------------------------------
| 404  | 未找到      | 混合连接路径无效或基 URL 格式不正确。
| 401  | 未授权   | 安全令牌丢失或格式不正确或无效。
| 403  | 禁止      | 安全令牌对此路径和此操作无效。
| 500  | 内部错误 | 服务内部出错。

如果服务在初始设置 WebSocket 连接后有意将其关闭，则会使用相应的 WebSocket 协议错误代码，连同也包含跟踪 ID 的描述性错误消息传达执行此操作的原因。

| WS 状态 | 描述
| --------- | ------------------------------------------------------------------------------- 
| 1000      | 侦听器关闭套接字。
| 1001      | 混合连接路径已删除或禁用。
| 1008      | 安全令牌已到期，因此违背了授权策略。
| 1011      | 服务内部出错。

### <a name="http-request-protocol"></a>HTTP 请求协议

HTTP 请求协议允许任意 HTTP 请求，但协议升级除外。
HTTP 请求指向实体的常规运行时地址，不包括用于混合连接 Web 套接字客户端的 $hc 中缀。

```
https://{namespace-address}/{path}?sbc-hc-token=...
```

_namespace-address_ 是托管混合连接的 Azure 中继命名空间的完全限定域名，通常格式为 `{myname}.servicebus.windows.net`。

请求可以包含任意其他 HTTP 头，包括应用程序定义的头。 提供的所有标头（RFC7230 中直接定义的标头除外，请参阅[请求消息](#Request message)）均流向侦听器并可在**请求**消息的 `requestHeader` 对象上找到。

查询字符串参数选项如下所示：

| Param          | 必需？ | 描述
| -------------- | --------- | ---------------- |
| `sb-hc-token`  | 是\*     | 侦听器必须为命名空间或混合连接提供有效的 URL 编码的服务总线共享访问令牌，以授予“**发送**”权限。

也可以在 `ServiceBusAuthorization` 或 `Authorization` HTTP 标头中携带该令牌。 如果混合连接配置为允许匿名请求，则可以省略该令牌。

由于服务实际上充当代理，因此，即使它不是真正的 HTTP 代理，也会添加 `Via` 标头，或批注符合 [RFC7230 第 5.7.1 部分](https://tools.ietf.org/html/rfc7230#section-5.7.1)的现有 `Via` 标头。
服务将中继命名空间主机名添加到 `Via`。

| 代码 | Message  | 描述                    |
| ---- | -------- | ------------------------------ |
| 200  | OK       | 请求已至少由一个侦听器处理。  |
| 202  | 已接受 | 请求已至少由一个侦听器接受。 |

如果出现错误，服务可能会提供以下回复。 可以通过 `Via` 标头的存在状态来判断响应是来自服务还是侦听器。 如果存在该标头，则响应来自侦听器。

| 代码 | 错误           | 描述
| ---- | --------------- |--------- |
| 404  | 未找到       | 混合连接路径无效或基 URL 格式不正确。
| 401  | 未授权    | 安全令牌丢失或格式不正确或无效。
| 403  | 禁止       | 安全令牌对此路径和此操作无效。
| 500  | 内部错误  | 服务内部出错。
| 503  | 错误的网关     | 无法将请求路由到任何侦听器。
| 504  | 网关超时 | 请求已路由到侦听器，但侦听器在所需的时限内未确认接收。

## <a name="next-steps"></a>后续步骤

* [中继常见问题](relay-faq.md)
* [创建命名空间](relay-create-namespace-portal.md)
* [.NET 入门](relay-hybrid-connections-dotnet-get-started.md)
* [节点入门](relay-hybrid-connections-node-get-started.md)
